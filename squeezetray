#!/usr/bin/env python
import wx
import time

import httplib, urllib
import sys
import socket
import time
from threading import *
import wx
from Queue import Queue
from threading import Thread

import sys, traceback
# simplejson is included with Python 2.6 and above
# with the name json
if float(sys.version[:3]) >= 2.6:
    import json
else:
    # python 2.4 or 2.5 can also import simplejson
    # as working alternative to the json included.
    import simplejson as json
    
    

TRAY_TOOLTIP = 'System Tray Demo'
TRAY_ICON = 'icon.png'


def create_menu_item(menu, label, func):
    item = wx.MenuItem(menu, -1, label)
    menu.Bind(wx.EVT_MENU, func, id=item.GetId())
    menu.AppendItem(item)
    return item





# Define notification event for thread completion
EVT_RESULT_ID = wx.NewId()

class ResultEvent(wx.PyEvent):
    """Simple event to carry arbitrary result data."""
    def __init__(self, data):
        """Init Result Event."""
        wx.PyEvent.__init__(self)
        self.SetEventType(EVT_RESULT_ID)
        self.data = data




class Worker(Thread):
    """Thread executing tasks from a given tasks queue"""
    def __init__(self, tasks):
        Thread.__init__(self)
        self.tasks = tasks
        self.daemon = True
        self.start()
    
    def run(self):
        while True:
            func, args, kargs = self.tasks.get()
            try: func(*args, **kargs)
            except Exception, e: print e
            self.tasks.task_done()

class ThreadPool:
    """Pool of threads consuming tasks from a queue"""
    def __init__(self, num_threads = 10):
        self.tasks = Queue(num_threads)
        for _ in range(num_threads): Worker(self.tasks)

    def add_task(self, func, *args, **kargs):
        """Add a task to the queue"""
        self.tasks.put((func, args, kargs))

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()


class Observable:
    def __init__(self, initialValue=None):
        self.data = initialValue
        self.callbacks = {}

    def addCallback(self, func):
        self.callbacks[func] = 1

    def delCallback(self, func):
        del self.callback[func]

    def _docallbacks(self):
        for func in self.callbacks:
            func(self.data)

    def set(self, data):
        self.data = data
        self._docallbacks()

    def get(self):
        return self.data

    def unset(self):
        self.data = None

class squeezePlayerMdl:
    def __init__(self,index,identifier = None, Name = None):
        self.index = Observable(index)
        self.identifier = Observable(identifier)
        self.name = Observable(Name)

class squeezeConMdle:
    def __init__(self):
        self.host = Observable("localhost")
        
        self.port = Observable("9000")
        self.connectionStr = Observable("localhost:9000")
        self.connected = Observable(False)
        self.playersCount = Observable(0)
        self.playerList = []
        self.host.addCallback(self.OnConnectionStrChange)
        self.port.addCallback(self.OnConnectionStrChange)
        self.connected.addCallback(self.OnConnectedChange)
        self.playersCount.addCallback(self.OnPlayersCountChange)
    def OnConnectionStrChange(self,value):
        NewConstr = "%s:%s" % (self.host.get(),self.port.get())
        OldConstr = self.connectionStr.get()
        if NewConstr != OldConstr:
            self.connectionStr.set(NewConstr)
    def OnConnectedChange(self,value):
        if not self.connected:
            self.playersCount.set(0)
    def OnPlayersCountChange(self,value):
        self.playerList = []
        for index in range(value):
            self.playerList.append(squeezePlayerMdl(index))
            
class SqueezeConnectionWorker(Thread):
    """Thread executing tasks from a given tasks queue"""
    def __init__(self, tasks):
        Thread.__init__(self)
        self.tasks = tasks
        self.daemon = True
        self.start()
    
    def run(self):
        while True:
            func,params = self.tasks.get()
            #print "fsdfsdFSDF= %s" % (params)
            try:
                self.conn.request("POST", "/jsonrpc.js", params)
            except socket.error:
                return
            try:
                response = self.conn.getresponse()
            except httplib.BadStatusLine:
                self.conn = httplib.HTTPConnection("mini.yokel.org:9000")
                self.conn.request("POST", "/jsonrpc.js", params)
                response = self.conn.getresponse()

            if response.status != 200:
                print response.status, response.reason
            #return response.read()
            rep = json.loads(response.read())
            if func != None:
                try: func(rep)
                except Exception, e: 
                    print e
                    #traceback.print_tb(e, limit=1, file=sys.stdout)
            self.tasks.task_done()
            
            
    def ConnectionSet(self,connectionStr):
        self.conn = httplib.HTTPConnection(connectionStr)
class SqueezeConnectionThreadPool:
    """Pool of threads consuming tasks from a queue"""
    def __init__(self, squeezeConMdle,num_threads = 10):
        
        self.squeezeConMdle = squeezeConMdle
        
        self.tasks = Queue(num_threads)
        self.arrayOfSqueezeConnectionWorker = []
        for _ in range(num_threads): 
            new = SqueezeConnectionWorker(self.tasks)
            self.arrayOfSqueezeConnectionWorker.append(new)

   

    def wait_completion(self):
        """Wait for completion of all the tasks in the queue"""
        self.tasks.join()
    def seldMessage(self,func,message):
        params = json.dumps(message, sort_keys=True, indent=4)
        self.tasks.put((func,params))
        
        
    def OnConnectionStrChange(self,value):
        for player in range(len(self.arrayOfSqueezeConnectionWorker)):
            self.arrayOfSqueezeConnectionWorker[player].ConnectionSet(value)
        self.squeezeConMdle.connected.set(False)
        self.seldMessage(self.OnPlayerCount,{ 
            "method":"slim.request",
            "params": [ '-', [ 'player', 'count', '?' ] ]
        })
        self.players = {}
    def OnPlayerCount(self,responce):
        
        noPlayers = int(responce["result"]["_count"])
        self.noPlayers = noPlayers
        print "self.noPlayers=%s" % ( noPlayers )
        self.squeezeConMdle.connected.set(True)
        self.squeezeConMdle.playersCount.set(noPlayers)
        self.players = []
        for index in range(self.noPlayers):
            self.players.append({'index' : index})
            msg = { 
                "method":"slim.request",
                "params": [ '-', [ 'player', 'id', index ,"?"] ]
            }
            self.seldMessage(self.OnPlayerIndex,msg)
            msg = { 
                "method":"slim.request",
                "params": [ '-', [ 'player', 'name', index ,"?"] ]
            }
            self.seldMessage(self.OnPlayerName,msg)

    def OnPlayerIndex(self,responce):
        
        playerId = responce["result"]["_id"]
        playerIndex = int(responce['params'][1][2])
        #print type(playerIndex)
        self.players[playerIndex].update({'id' : playerId})
        #self.squeezeConMdle.playerIndex(playerIndex,playerId)
        print "self.players=%s" % (self.players)
        self.squeezeConMdle.playerList[playerIndex].identifier.set(playerId)
    def OnPlayerName(self,responce):
        playerName = responce["result"]["_name"] 
        playerIndex = int(responce['params'][1][2])
        self.players[playerIndex].update({'name' : playerName})
        print "self.players=%s" % (self.players)
        self.squeezeConMdle.playerList[playerIndex].name.set(playerName)
       
class squeezeConCtrl:
    def __init__(self):  
        self.model = squeezeConMdle()
        self.view1 = SqueezeConnectionThreadPool(self.model)
        self.model.connectionStr.addCallback(self.view1.OnConnectionStrChange)
        self.model.playersCount.addCallback(self._OnPlayersCountChange)
        self.mapping = {}
    def ConectionStringSet(self,Conecxtionstring):
        oldConecxtionstring = self.model.connectionStr.get()
        if oldConecxtionstring != Conecxtionstring:
            self.model.connectionStr.set(Conecxtionstring)
    def ServerHostSet(self,hostname):
        oldHost = self.model.port.get()
        if oldHost != hostname:
            self.model.host.set(hostname)
    def ServerPortSet(self,port):
        oldPort = self.model.port.get()
        if oldPort != port:
            self.model.port.set(port)
    def _OnPlayersCountChange(self,value):
        self.mapping = {}
        for index in range(value):
            name = self.model.playerList[index].name.addCallback(self._OnPlayersNameChange)
    def _OnPlayersNameChange(self,value):
        playersCount = self.model.playersCount.get()
        for index in range(playersCount):
            print self.model.playerList[index].name.get()
            self.mapping[value] = index
            
    def PlayersList(self):
        return lest(self.mapping.keys())
        
            
            
            
    def Pause(self,player):
        if not self.model.connected.get():
            return None
        if not player in self.mapping:
            return None
        playerIndex = self.mapping[player]
        playerId = self.model.playerList[playerIndex].identifier.get()
        reponce = self.view1.seldMessage(None,{ 
            "id":playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["pause"]
                ]
        })
    def Play(self,player):
        if not self.model.connected.get():
            return None
        if not player in self.mapping:
            return None
        playerIndex = self.mapping[player]
        playerId = self.model.playerList[playerIndex].identifier.get()
        reponce = self.view1.seldMessage(None,({ 
            "id" : playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["play"]
                ]
        }))
    def Index(self,player,Count):
        if not self.model.connected.get():
            return None
        if not player in self.mapping:
            return None
        prefix = ""
        if Count > 0:
            prefix = "+"
        playerIndex = self.mapping[player]
        playerId = self.model.playerList[playerIndex].identifier.get()
        reponce = self.view1.seldMessage(None,({ 
            "id":playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["playlist","index",prefix + str(Count)]
                ]
        }))


    def PlayRandomSong(self,player):
        if not self.model.connected.get():
            return None
        if not player in self.mapping:
            return None
        prefix = ""
        if Count > 0:
            prefix = "+"
        playerIndex = self.mapping[player]
        playerId = self.model.playerList[playerIndex].identifier.get()
        reponce = self.view1.seldMessage(None,({ 
            "id":playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["randomplay",'tracks']
                ]
            }))
class squeezecmd:
    def __init__(self):
        self.connected = False
    def SetSqueezeServerHost(self, Host):
        changed = False
        if not hasattr(self,'Host'):
            self.Host = Host
            changed = True
        else:
            if self.Host != Host:
                changed = True
                self.Host = Host
        if changed:
            self.OnHostChange()
    def GetSqueezeServerHost(self):
        if not hasattr(self,'Host'):
            return 'localhost'
        else:
            return self.Host
    def SetSqueezeServerPort(self, Port):
        changed = False
        if not hasattr(self,'Port'):
            self.Port = Port
            changed = True
        else:
            if self.Port != Port:
                changed = True
                self.Port = Port
        if changed:
            self.OnHostChange()

    def GetSqueezeServerPort(self):
        if not hasattr(self,'host'):
            return '9000'
        else:
            return self.Port
    def OnHostChange(self):
        Changed = False
        constr = "%s:%s" % (self.GetSqueezeServerHost(),self.GetSqueezeServerPort())
        #print constr
        if not hasattr(self,'_constr'):
            self._constr = constr
            Changed = True
        if self._constr != constr:
            Changed = True
            self._constr = constr
        if not Changed:
            return
        #print "here"
        if hasattr(self,'players'):
            del(self.players)
        self.conn = httplib.HTTPConnection(self._constr)
        reponce = self.sendmsg({ 
            "method":"slim.request",
            "params": [ '-', [ 'player', 'count', '?' ] ]
        })
        if reponce == None:
            return
        rep = json.loads(reponce)
        if rep == None:
            return
        players = {}
        self.noPlayers = rep["result"]["_count"]
        for index in range(self.noPlayers):
            reponce = self.sendmsg({ 
                "method":"slim.request",
                "params": [ '-', [ 'player', 'id', index ,"?"] ]
            })
            rep = json.loads(reponce)
            playerId = rep["result"]["_id"]
            reponce = self.sendmsg({ 
                "method":"slim.request",
                "params": [ '-', [ 'player', 'name', index ,"?"] ]
            })
            rep = json.loads(reponce)
            playerName = rep["result"]["_name"]
            playerDetails = {"name" : playerName,
                "id" : playerId,
                "index" : index }
            players[playerName] = playerDetails
        self.players = players
        self.connected = True
        return
    def GetSqueezeServerPlayers(self):
        if  hasattr(self,'players'):
            return self.players.keys()
        return []
    def hasPlayer(self,player):
        if not player in self.GetSqueezeServerPlayers():
            return False
        return True
    def GetSqueezeServerConnected(self):
        return self.connected
    
    def sendmsg(self,msg):
        if not hasattr(self,'conn'):
            return
        params = json.dumps(msg, sort_keys=True, indent=4)
        try:
            self.conn.request("POST", "/jsonrpc.js", params)
        except socket.error:
            return
        try:
            response = self.conn.getresponse()
        except httplib.BadStatusLine:
            self.conn = httplib.HTTPConnection("mini.yokel.org:9000")
            self.conn.request("POST", "/jsonrpc.js", params)
            response = self.conn.getresponse()
        if response.status != 200:
            print response.status, response.reason
        return response.read()
    def squeezecmd_play(self,player):
        if not self.hasPlayer(player):
            return None
        playerIndex = self.players[player]["index"]
        playerId =self.players[player]["id"]
        reponce = self.sendmsg({ 
            "id" : playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["play"]
                ]
        })
        
        
    def squeezecmd_pause(self,player):
        if not self.hasPlayer(player):
            return None
        playerIndex = self.players[player]["index"]
        playerId =self.players[player]["id"]
        reponce = self.sendmsg({ 
            "id":playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["pause"]
                ]
        })
    def squeezecmd_randomplay(self,player):
        playerIndex = self.players[player]["index"]
        playerId =self.players[player]["id"]
        reponce = self.sendmsg({ 
            "id":playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["randomplay",'tracks']
                ]
            })
    def squeezecmd_Index(self,player,Count):
        """Jumps player on currentplaylist"""
        prefix = ""
        if Count > 0:
            prefix = "+"
        playerIndex = self.players[player]["index"]
        playerId =self.players[player]["id"]
        reponce = self.sendmsg({ 
            "id":playerIndex,
            "method":"slim.request",
            "params":[ playerId, 
                    ["playlist","index",prefix + str(Count)]
                ]
        })

class TaskBarIcon(wx.TaskBarIcon):
    def __init__(self,sc):
        super(TaskBarIcon, self).__init__()
        self.set_icon(TRAY_ICON)
        
        self.Bind(wx.EVT_TASKBAR_MOVE, self.on_move)
        self.Bind(wx.EVT_TASKBAR_LEFT_DOWN, self.on_left_down)
        self.Bind(wx.EVT_TASKBAR_LEFT_UP, self.on_left_up )
        #self.Bind(wx.EVT_TASKBAR_RIGHT_DOWN, self.on_right_down )
        #self.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.on_right_up )
        self.Bind(wx.EVT_TASKBAR_LEFT_DCLICK, self.on_left_dclick)
        self.Bind(wx.EVT_TASKBAR_RIGHT_DCLICK, self.on_right_dclick)
        #self.Bind(wx.EVT_TASKBAR_CLICK, self.on_click )
        self.squeezecmd = sc
        self.Example = None
        self.Connect(-1, -1, EVT_RESULT_ID, self.OnResult)
    def GetSqueezeServerPlayer(self):
        if not hasattr(self,'app'):
            return None
        return self.app.GetSqueezeServerPlayer()
    def OnShowPopup(self, event):
        pos = wx.GetMousePosition()
        #pos = event.GetPosition()
        
        
        
        #pos = self.panel.ScreenToClient(pos)

    
    def CreatePopupMenu(self):
        toolsMENU = wx.Menu()
        create_menu_item(toolsMENU, 'Play', self.onScPlay)
        create_menu_item(toolsMENU, 'Pause', self.onScPause)
        create_menu_item(toolsMENU, 'Next', self.onScNext)
        create_menu_item(toolsMENU, 'Previous', self.onScPrevious)
        create_menu_item(toolsMENU, 'Rnd', self.onScRandom)
        #machinesMENU = wx.Menu() 
        
        #moldsMENU = wx.Menu() 
        #toolsMENU.AppendMenu(-1, "Command", machinesMENU) 
        
        
        #toolsMENU.AppendMenu(-1, "Molds", moldsMENU) 

        #create_menu_item(moldsMENU, 'Say Hello', self.on_hello)
        toolsMENU.AppendSeparator()
        create_menu_item(toolsMENU, 'Settings', self.on_settings)
        toolsMENU.AppendSeparator()
        create_menu_item(toolsMENU, 'Exit', self.on_exit)
        return toolsMENU
    def set_icon(self, path):
        icon = wx.IconFromBitmap(wx.Bitmap(path))
        self.SetIcon(icon, TRAY_TOOLTIP)
    def on_move(self, event):
        #print 'on_move'
        pass
        
        #print self.ScreenToClient(wx.GetMousePosition())
    def on_left_up(self, event):
        #print 'on_left_up'
        pass
    
    def on_right_down(self, event):
        #print 'on_right_down'
        pass
    def on_right_up(self, event):
        #print 'on_right_up'
        menu = self.CreatePopupMenu()
        #print dir (menu)
    def on_right_dclick(self, event):
        #print 'on_right_dclick'
        self.frame.PopupMenu( menu, event.GetPoint() )
    def on_click(self, event):
        #print 'on_click'
        pass
    
    def on_left_down(self, event):
        #print 'Tray icon was left-clicked.'
        pass
    def on_left_dclick(self, event):
        #print 'Tray icon was on_left_dclick-clicked.'
        self.set_icon('gnomedecor1.png')
        self.OnShowPopup( event)
    def on_hello(self, event):
        print 'Hello, world!'
    def on_exit(self, event):
        self.on_settings_close(event)
        wx.CallAfter(self.Destroy)
    def onScPlay(self, event):
        player = self.GetSqueezeServerPlayer()
        if player != None:
            self.app.squeezeConCtrl.Play(player)
        else:
            self.on_settings(event)
    
    def onScPause(self, event):
        player = self.GetSqueezeServerPlayer()
        if player != None:
            self.app.squeezeConCtrl.Pause(player)
        else:
            self.on_settings(event)
    def onScNext(self, event):
        player = self.GetSqueezeServerPlayer()
        if player != None:
            #self.squeezecmd.squeezecmd_Index(player,1)
            
            self.app.squeezeConCtrl.Index(player,1)
        else:
            self.on_settings(event)
    def onScPrevious(self, event):
        player = self.GetSqueezeServerPlayer()
        if player != None:
            #self.squeezecmd.squeezecmd_Index(player,-1)
            self.app.squeezeConCtrl.Index(player,-1)
        else:
            self.on_settings(event)
    def onScRandom(self, event):
        player = self.GetSqueezeServerPlayer()
        if player != None:
            #self.squeezecmd.squeezecmd_randomplay(player)
            self.app.squeezeConCtrl.PlayRandom(player)
        else:
            self.on_settings(event)


    def on_settings(self, event):
        if (self.Example == None):
            self.Example = Example(None, title='Settings')
            self.Example.Bind(wx.EVT_CLOSE, self.on_settings_close)
            self.Example.cfg = self.cfg
            self.Example.app = self.app
            self.Example.Show()
    def on_settings_close(self, event):
        if (self.Example != None):
            self.Example.Destroy()
            self.Example = None

    def OnResult(self, event):
        """Show Result status."""
        if event.data is None:
            # Thread aborted (using our convention of None return)
            self.status.SetLabel('Computation aborted')
        else:
            # Process results here
            self.status.SetLabel('Computation Result: %s' % event.data)
        # In either event, the worker is done
        self.worker = None

        
class Example(wx.Frame):
  
    def __init__(self, parent,  title):
        
        self.parent = parent
        self.title = title
        w, h = (250, 250)
        wx.Frame.__init__(self, self.parent, -1, self.title, wx.DefaultPosition, wx.Size(w, h))
        self.CreateStatusBar()
        
        self.SetStatusText("Demonstration of wxPython")
        self.sizer = wx.GridBagSizer(8, 3)
        
        
        self.BtnApply = wx.Button(self,-1, "Apply")
        self.BtnCancel = wx.Button(self,-1, "Cancel")
        self.BtnSave = wx.Button(self,-1, "Save")
        

        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.BtnCancel.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnSave,id=self.BtnSave.GetId())
        self.Bind(wx.EVT_BUTTON, self.OnApply,id=self.BtnApply.GetId())

        
        
        
        self.sizer.Add(self.BtnApply, (8, 0), wx.DefaultSpan, wx.EXPAND)
        self.sizer.Add(self.BtnCancel, (8, 1), wx.DefaultSpan, wx.EXPAND)
        self.sizer.Add(self.BtnSave, (8, 2), wx.DefaultSpan, wx.EXPAND)
        
        label1 = wx.StaticText(self, -1, 'Host:')
        
        self.sizer.Add(label1, (0, 0), wx.DefaultSpan, wx.EXPAND)
        
        self.tcHost = wx.TextCtrl(self, -1 )
        self.sizer.Add(self.tcHost , (0, 1), (1,2), wx.EXPAND)
        label2 = wx.StaticText(self, -1, 'Port:')
        
        
        self.sizer.Add(label2, (1, 0), wx.DefaultSpan, wx.EXPAND)
        label3 = wx.StaticText(self, -1, 'Player:')
        
        self.sizer.Add(label3, (2, 0), wx.DefaultSpan, wx.EXPAND)
        
        self.scPort = wx.SpinCtrl(self, -1, str(9000),  min=1, max=99999)
        self.sizer.Add(self.scPort, (1, 1),wx.DefaultSpan, wx.EXPAND)
        #self.statusbar = self.CreateStatusBar()
        #self.sizer.Add(self.statusbar, (9, 0),(2,9), wx.EXPAND)
        
        self.cbPlayer = wx.ComboBox(self, -1, style=wx.CB_READONLY)
        self.sizer.Add(self.cbPlayer, (2, 1), (1,2), wx.EXPAND)
        
        
        self.sizer.AddGrowableRow(8)
        self.sizer.AddGrowableCol(0)
        self.sizer.AddGrowableCol(1)
        self.sizer.AddGrowableCol(2)
        
        self.SetSizerAndFit(self.sizer)
    
    def Show(self):
        self.OnUpdate()
        
        self.tcHost.SetValue(self.app.GetSqueezeServerHost())
        self.scPort.SetValue(self.app.GetSqueezeServerPort())
        
        self.Centre()
        #self.SetSize(wx.Size(w, h))
        super(Example, self).Show()

    def OnUpdate(self):
        
        self.cbPlayer.Clear()
        
        availablePlayers = self.app.ConMan.GetSqueezeServerPlayers()
        
        if True == self.app.ConMan.GetSqueezeServerConnected():
            self.SetStatusText("Server Connected.")
        else:
            self.SetStatusText("Server not connected.")
        
        for player in availablePlayers:
            self.cbPlayer.Append(player)
        if len(availablePlayers) > 0:
            CurrentPlayer = self.app.GetSqueezeServerPlayer()
            playerIndex = 0
            if CurrentPlayer != None:
                try:
                    playerIndex = availablePlayers.index(CurrentPlayer)
                except:
                    playerIndex = 0
            self.cbPlayer.SetSelection(playerIndex)
        
    def OnSave(self, event):
        self.OnApply(event)
        self.app.configSave()

    def OnApply(self, event):
        self.app.SetSqueezeServerHost(self.tcHost.GetValue())
        self.app.SetSqueezeServerPort(int(self.scPort.GetValue()))
        self.app.SetSqueezeServerPlayer(self.cbPlayer.GetValue())
        self.OnUpdate()
    def OnCancel(self, event):
        self.app.tb.on_settings_close(event)
        

def runner(context):
    """Run Worker Thread."""
    # This is the code executing in the new thread. Simulation of
    # a long process (well, 10s here) as a simple loop - you will
    # need to structure your processing so that you periodically
    # peek at the abort variable
    for i in range(10):
        time.sleep(1)
        if context._want_abort:
            # Use a result of None to acknowledge the abort (of
            # course you can use whatever you'd like or even
            # a separate event type)
            wx.PostEvent(context, ResultEvent(None))
            return
    # Here's where the result would be returned (this is an
    # example fixed result of the number 10, but it could be
    # any Python object)
    wx.PostEvent(context, ResultEvent(10))

def runner2(context,naughtyApp):
    model = naughtyApp.model
    connection = context
    

class myapp(wx.App):
    def __init__(self):
        super(myapp, self).__init__()
        
        self.model = {}
        self.SqueezeServerPort = None
        self.cfg = wx.FileConfig(appName="ApplicationName", 
                                    vendorName="VendorName", 
                                    localFilename=".squeezetray.cfg", 
                                    style=wx.CONFIG_USE_LOCAL_FILE)
        self.squeezeConCtrl = squeezeConCtrl()
        self.configRead()
        self.ConMan = squeezecmd()
        self.ConMan.SetSqueezeServerHost(self.GetSqueezeServerHost())
        self.ConMan.SetSqueezeServerPort(self.GetSqueezeServerPort())
        
        
        self.tb = TaskBarIcon(self.ConMan)
        self.tb.app = self
         
        
        self.tb.cfg = self.cfg
        
        
        #self.squeezeConCtrl.Pause()
        
        #self.squeezeConCtrl.ConectionStringSet("%s:%s" % (self.GetSqueezeServerHost(),self.GetSqueezeServerPort()))
    def configRead(self):
        squeezeServerHost = 'localhost'
        if self.cfg.Exists('squeezeServerHost'):
            squeezeServerHost = self.cfg.Read('squeezeServerHost')
            
        self.SetSqueezeServerHost(squeezeServerHost)
        squeezeServerPort = 9000
        if self.cfg.Exists('squeezeServerPort'):
            try:
                squeezeServerPortTmp = int(self.cfg.ReadInt('squeezeServerPort'))
            except ValueError:
                squeezeServerPort = 9000
        self.SetSqueezeServerPort(9000)
        SqueezeServerPlayer = None
        if self.cfg.Exists('SqueezeServerPlayer'):
            SqueezeServerPlayer = self.cfg.Read('SqueezeServerPlayer')
        self.SetSqueezeServerPlayer(SqueezeServerPlayer)
        self.squeezeConCtrl.ConectionStringSet("%s:%s" % (self.GetSqueezeServerHost(),self.GetSqueezeServerPort()))
        
    def configSave(self):
        self.cfg.Write("squeezeServerHost", self.GetSqueezeServerHost())
        self.cfg.WriteInt("squeezeServerPort", self.GetSqueezeServerPort())
        self.cfg.Write("SqueezeServerPlayer", self.GetSqueezeServerPlayer())
        self.cfg.Flush()
    def SetSqueezeServerHost(self,host):
        Changed = False
        if not hasattr(self,'SqueezeServerHost'):
            Changed = True
            self.SqueezeServerHost = 'localhost'
        if self.SqueezeServerHost != host:
            Changed = True
        try:
            self.SqueezeServerHost = str(host)
        except TypeError:
            self.SqueezeServerHost = 'localhost'
        if hasattr(self,'ConMan'):
            self.ConMan.SetSqueezeServerHost(self.SqueezeServerHost)
        self.squeezeConCtrl.ServerHostSet(self.SqueezeServerHost)
        port = self.GetSqueezeServerPort() 
        host = self.GetSqueezeServerHost()
        if host != None and port != None:
            self.squeezeConCtrl.ConectionStringSet("%s:%s" % (self.GetSqueezeServerHost(),self.GetSqueezeServerPort()))
        
    def GetSqueezeServerHost(self):
        if hasattr(self,'SqueezeServerHost'):
            return self.SqueezeServerHost
        return 'localhost'
        
        
    def SetSqueezeServerPort(self,port):
        Changed = False
        if not hasattr(self,'SqueezeServerPort'):
            Changed = True
            self.SqueezeServerPort = 9000
        if self.SqueezeServerPort != port:
            Changed = True
            try:
                self.SqueezeServerPort = int(port)
            except TypeError:
                squeezeServerPort = 9000
        if hasattr(self,'ConMan'):
            self.ConMan.SetSqueezeServerPort(self.SqueezeServerPort)
        self.squeezeConCtrl.ServerPortSet(self.SqueezeServerPort)
        port = self.GetSqueezeServerPort() 
    def GetSqueezeServerPort(self):
        if hasattr(self,'SqueezeServerHost'):
            return self.SqueezeServerPort
        return 9000
    def SetSqueezeServerPlayer(self,player):
        self.SqueezeServerPlayer = player
        
        
        
    def GetSqueezeServerPlayer(self):
        
        
        if hasattr(self,'SqueezeServerPlayer'):
            return self.SqueezeServerPlayer
        return None
    
        
    
        
def main():
    app = myapp()
    app.MainLoop()

if __name__ == '__main__':
    main()
